Задание:

Требуется реализовать блокирующую очередь с приоритетами, для асинхронного
обмена сообщениями между несколькими потоками «писателей» и «читателей», и
тестовое приложение, демонстирующее его функциональность.
Класс MessageQueue должен поддерживать механизм HWM/LWM (high water mark/low
water mark), приоритеты сообщений, и блокирующий вызов get (вызов блокируется, до
появления сообщения в очереди).

Замечания:

Для работы с много-поточностью для кросс-платформ была взята свободная имплементация TinyThread для WIN32/POSIX. 
В программе использованы из TinyThread след. классы: thread, recursive_mutex and condition_variable.

Класс MessageQueue работает с указанным типом сообщения через темплэйт, обеспечивает блокирующую очередь со сортировкой приоритетов (max->min). 
Также обеспечивает асинхронный обмен сообщений и блокирующие чтение до пополнения очереди, либо до остановки работы объекта.
Поддерживает HWM/LWM и интерфейс событий своего состояния. 
Класс не создает никаких нитей и создается в главной процедуре.
Также имеет функцию MessageQueue::Stop() для остановки работы райтеров и ридеров через нотификации по интерфейсу райтера и код возврата для ридера.

Класс Reader и Writer имеют метод run() для запуска собственного потока, этот метод вызываються из главной процедуры в разное время для анализа работы очереди.

Класс EventManager был создан отдельно от очереди (хотя его можно имплементировать и в MessageQueue).
Этот класс обеспечивает распространения событий по указанным через интерфейс объектам.

В данном примере создается три райтера, которым дается генерировать сообщения в одиночку без ридеров.
Затем создаются три ридера а запускается все объекты работать на 5 секунд.
В течение этих секунд мы наблюдаем поведение системы, которое собрано в лог файле по stderr стриму. В стандартный стрим программа печатает прочитанные сообщения.

Данная версия всегда печатает лог в stderr.
Для создания отдельного файла логов необходимо запустить: >> message_queue.exe 2>log.txt
